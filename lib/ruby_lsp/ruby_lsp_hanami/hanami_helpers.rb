# typed: true
# frozen_string_literal: true
require_relative "key_forest"

module RubyLsp
  # top level comment
  #
  module Hanami
    extend T::Sig

    @key_forest = nil
    # dumb
    CONTAINERS = %w[deps app].freeze
    KeyType = T.type_alias { T.any(T::Array[String], String) }

    sig { params(key: KeyType, value: RubyIndexer::Entry).void }
    def self.add_key_entry(key, value)
      @key_forest = KeyForest.new if @key_forest.nil?
      # convert key to downcase snake case
      # taken from: https://gist.github.com/cjmeyer/4268723
      key = key.is_a?(Array) ? key.join(".") : key
      formatted_key = key.gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
                         .gsub(/([a-z])([A-Z])/, '\1_\2')
                         .downcase

      @key_forest.add_entry(key: formatted_key, entry: value)
    end

    # optionally pass in the index generated by the RubyLsp
    # if not given, only search our own index
    sig { params(key: KeyType, lsp_index: T.nilable(RubyIndexer::Index)).returns(T::Array[RubyIndexer::Entry]) }
    def self.get_entries(key:, lsp_index: nil)
      return [] if @key_forest.nil? && lsp_index.nil?

      matched = if @key_forest.nil?
                  []
                else
                  [@key_forest.entry(key: key)].compact
                end

      unless lsp_index.nil?
        key_parts = key.is_a?(Array) ? key : key.split(".")
        matched += lsp_index.resolve(key_parts.last,
                                       key_parts[0, key_parts.length - 1]) || []
      end

      matched.uniq!
      matched
    end

    sig { params(key: KeyType).returns(T::Boolean) }
    def self.container_key?(key:)
      return false if @key_forest.nil?

      @key_forest.key?(key: key)
    end

    sig { params(key: KeyType).returns(T::Array[RubyIndexer::Entry]) }
    def self.completion_options(key:)
      return [] if @key_forest.nil?

      @key_forest.completion_options(key: key)
    end

    def self.key_forest
      @key_forest
    end

    sig { void }
    def self.clear_entries
      @key_forest&.forest_fire
    end
  end
end
